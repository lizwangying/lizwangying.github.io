---
title: Kotlin Coroutines（协程）
date: 2020-10-18 19:33:09
tags: kotlin
category: Kotlin
toc: true
---  
**阅读《深入理解Kotlin协程》—— 霍丙乾  的读书笔记，博客内容多数为摘抄和总结，侵删。**

注意：大家过年回家的抢票软件是携程，而我们 Kotlin 的 coroutines 翻译过来是协程。从名字看大概能猜到是异步的代码相互协作的程序。

## What is Kotlin Corutines
**协程**: 就是函数或者一段程序能够被 `挂起` ，稍后再挂起的位置 `恢复` 。而线程是一旦开始就不会暂停，直到任务结束。线程之间是抢占式的调度，因此不存在协作问题。

`挂起` 和 `恢复` 是协程主动让出运行权来实现协作的，协程和核心也是程序自己处理挂起和恢复。

线程的调度一般是由操作系统实现控制的，而大多数协程是由于语言层面自己实现。

协程需要支持挂起和恢复，因此需要对挂起点的状态进行保存，他们是否开辟相应的调用栈有两种实现方式。  

* **有栈协程（Stackful Coroutine）**:协程有自己的调用栈，类似线程的，实现方式就类似线程的调度，不同点体现在调度上。
* **无栈协程（Stackless Coroutine）**：协程没有自己的调用栈，挂起点的状态通过状态机或者闭包等语法实现。有栈协程总是会给协程开辟一块内存，因此内存消耗大大增加，而无栈协程就在内存方面比较有优势。（今年面试第一次被问到闭包，原来是因为这个。）

Kotlin 的协程是一种无栈协程，他的控制流转依靠对协程体本身编译生成的装填机的状态流转实现。变量保存也是通过闭包语法来实现的。

调度过程中，根据协程调度权的转移目标不同又可以将协程分为 `对协协程` 和 `非对协协程`。

* **对协协程（Symmetric Coroutine）** ：任何一个协程都是相互独立且平等的，调度前可以再任意协程之间转移。
* **非对协协程（Asymmetric Coroutine）**：协程让出到底全的目标只能是他的调度者，即协程之间存在调用和被调用的关系。





## How is that work ?

## Why use it ?