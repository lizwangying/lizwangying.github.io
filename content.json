{"pages":[],"posts":[{"title":"二叉树入门","text":"二叉树遍历分为： 二叉树深度优先遍历 ( DFS ，即为 Depth First Search ) 前序遍历 中序遍历 后序遍历 二叉树广度优先遍历 (BFS，即为 Breadth First Search ) 层序优先遍历 记忆心得：前中后 是将 根节点 作为参照物，比如前序就是 根节点 第一个遍历，中序就是 根节点 中间遍历，后序就是 根节点 最后。 后文以此棵二叉树为例： 1234567 F / \\ B G /\\ \\A D I /\\ / C E H 前序遍历前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。结果：F B A D C E G I H 中序遍历中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。结果：A B C D E F G H I 通常来说，对于二叉搜索树，我们可以通过中序遍历得到一个递增的有序序列。 后序遍历后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。结果：A C E D B H I G F 值得注意的是，当你删除树中的节点时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身。 另外，后序在数学表达中被广泛使用。 编写程序来解析后缀表示法更为容易。 这里是一个例子： 1234567 + / \\ * 5 /\\4 - / \\ 7 2 中序遍历：4 * 7 - 2 + 5后序遍历：4 7 2 - * 5 + 您可以使用中序遍历轻松找出原始表达式。 但是程序处理这个表达式时并不容易，因为你必须检查操作的优先级。 如果你想对这棵树进行后序遍历，使用栈来处理表达式会变得更加容易。 每遇到一个操作符，就可以从栈中弹出栈顶的两个元素，计算并将结果返回到栈中。 后序遍历 4 7 2 - * 5 + 的入栈出栈可演示为： 4 入栈 7 入栈 2 入栈 - 弹出两个元素 * 弹出两个元素 5 入栈 + 弹出两个元素 4 7 2 7-2 4 * 7 - 2 5 4 * 7 - 2 + 5 4 7 4 4 * 7 - 2 4 层序遍历层序遍历就是逐层遍历树结构。通常，我们使用一个叫做队列（Queue）的数据结构来帮助我们做广度优先搜索（BFS）。结果：F B G A D I C E H 例题: 二叉树的层序遍历 截题模板：负雪明烛 发布于 2020-05-13 19.7k 访问 BFS使用队列，把每个还没有搜索到的点依次放入队列，然后再弹出队列的头部元素当做当前遍历点。BFS总共有两个模板： 如果不需要确定当前遍历到了哪一层，BFS模板如下。 12345while queue 不空： cur = queue.pop() for 节点 in cur的所有相邻节点： if 该节点有效且未访问过： queue.push(该节点) 如果要确定当前遍历到了哪一层，BFS模板如下。这里增加了level表示当前遍历到二叉树中的哪一层了，也可以理解为在一个图中，现在已经走了多少步了。size表示在当前遍历层有多少个元素，也就是队列中的元素数，我们把这些元素一次性遍历完，即把当前层的所有元素都向外走了一步。 12345678910level = 0while queue 不空： size = queue.size() while (size --) { cur = queue.pop() for 节点 in cur的所有相邻节点： if 该节点有效且未被访问过： queue.push(该节点) } level ++; 上面两个是通用模板，在任何题目中都可以用，是要记住的！ 本题要求二叉树的层次遍历，所以同一层的节点应该放在一起，故使用模板二。 使用队列保存每层的所有节点，每次把队列里的原先所有节点进行出队列操作，再把每个元素的非空左右子节点进入队列。因此即可得到每层的遍历。 递归遍历二叉树输入: [1,null,2,3] 123451 \\ 2 / 3 输出: [1,2,3] 解题代码： 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } * -------------------- * coding 中遇到的问题： * 1. 递归过程中 new 对象很浪费资源，并且会被覆盖，怎么创建对象呢？ * 不能重复创建对象，尤其是返回值，所以需要将递归的部分新建一个函数， * 创建对象放在外面，返回值作为参数传递给递归函数，新建对象放在调用递归之前。 * 2. 内循环开始 return 的时机是什么？ * 常见是当前元素判断为空。 * 3. 整个递归的结果怎么 return? * 递归函数的参数记录最终的返回值。 */class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList(); traversal(root,result); return result; } public void traversal(TreeNode root , List&lt;Integer&gt; result){ if(root != null){ result.add(root.val); if(root.left != null){ traversal(root.left,result); } if(root.right != null){ traversal(root.right,result); } }else{ return; } }} 递归要素1. 确定递归函数的参数和返回值：确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 2.确定终止条件：写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 3.确定单层递归的逻辑：确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 递归解决二叉树问题练习题 简单：二叉树的最大深度给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 12345 3 / \\9 20 / \\ 15 7 返回它的最大深度 3 。 简单：对称二叉树 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 12345 1 / \\ 2 2 / \\ / \\3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 12345 1 / \\2 2 \\ \\ 3 3 简单：路径总和 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例: 给定如下二叉树，以及目标和 sum = 22， 12345678 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 迭代遍历二叉树迭代法一般都使用栈来实现。栈是先入后出，所以入栈顺序需要注意。 总结了解递归并利用递归解决问题并不容易。 当遇到树问题时，请先思考一下两个问题： 你能确定一些参数，从该节点自身解决出发寻找答案吗？你可以使用这些参数和节点本身的值来决定什么应该是传递给它子节点的参数吗？如果答案都是肯定的，那么请尝试使用 “自顶向下” 的递归来解决此问题。 或者你可以这样思考：对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出该节点的答案吗？ 如果答案是肯定的，那么 “自底向上” 的递归可能是一个不错的解决方法。 题外话 下面是Java中Queue的一些常用方法： 方法名 作用 异常处理 add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 offer 添加一个元素并返回true 如果队列已满，则返回false poll 移除并返问队列头部的元素 如果队列为空，则返回null peek 返回队列头部的元素 如果队列为空，则返回null put 添加一个元素 如果队列满，则阻塞 take 移除并返回队列头部的元素 参考https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/x63shc/ 作者：fuxuemingzhu链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/tao-mo-ban-bfs-he-dfs-du-ke-yi-jie-jue-by-fuxuemin/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 作者：力扣 (LeetCode)链接：https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xefb4e/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2020/09/29/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"DFS 与 BFS 的特点比较","text":"树是非线性结构，对于存储一棵树不需要大块的连续内存，有利于提高计算机资源利用率。在实际生活场景中，深度优先搜索（DFS）和广度优先搜（BFS）索分别有哪些使用场景呢？ BFS 实际场景：BFS 求解 最短路径 或者 二分图判断 、最小生成树 ； 使用 队列 实现，一般会借助 哈希表 来优化时间复杂度； DFS 实际场景：文件目录的遍历，查找符合要求的文件。 一般使用 栈 实现，递归解法较容易实现； 和树的深度成正比，如果树比较深的话建议用 BFS。 使用 DFS 深度优先遍历 给定一个二叉树，请寻找它的最大深度。 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 3 / 9 20 / 15 7返回它的最大深度 3 。 123456789101112class Solution { public int maxDepth(TreeNode root) { if (root == null) { return 0; } else { int leftHeight = maxDepth(root.left); int rightHeight = maxDepth(root.right); return Math.max(leftHeight, rightHeight) + 1; } }} 判断二叉树是否对称 递归解法： 双指针判断 迭代解法：层序遍历，根节点入队列两次，然后每次拉出来两个节点对比是否相等 前序遍历（自顶向下）根节点的深度是1。depth = 1, answer = 0; 1234567891011private int answer;private void maximum_depth(TreeNode root, int depth) { if (root == null) { return; } if (root.left == null &amp;&amp; root.right == null) { answer = Math.max(answer, depth); } maximum_depth(root.left, depth + 1); maximum_depth(root.right, depth + 1);} 后序遍历（自底向上）12345678public int maximum_depth(TreeNode root) { if (root == null) { return 0; // return 0 for null node } int left_depth = maximum_depth(root.left); int right_depth = maximum_depth(root.right); return Math.max(left_depth, right_depth) + 1; // return depth of the subtree rooted at root} 使用 BFS 进行层序遍历「BFS 遍历」、「层序遍历」、「最短路径」实际上是递进的关系。在 BFS 遍历的基础上区分遍历的每一层，就得到了层序遍历。在层序遍历的基础上记录层数，就得到了最短路径。 BFS 遍历是一类很值得反复体会和练习的题目。一方面，BFS 遍历是一个经典的基础算法，需要重点掌握。另一方面，我们需要能根据题意分析出题目是要求最短路径，知道是要做 BFS 遍历。 LeetCode 102 二叉树的层序遍历 123456789101112131415161718192021222324252627public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); if (root != null) { queue.add(root); } while (!queue.isEmpty()) { int n = queue.size(); List&lt;Integer&gt; level = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } res.add(level); } return res;} 使用 BFS 求解最短路径问题在一棵树中，一个结点到另一个结点的路径是唯一的，但在图中，结点之间可能有多条路径，其中哪条路最近呢？这一类问题称为最短路径问题。最短路径问题也是 BFS 的典型应用，而且其方法与层序遍历关系密切。 在二叉树中，BFS 可以实现一层一层的遍历。在图中同样如此。从源点出发，BFS 首先遍历到第一层结点，到源点的距离为 1，然后遍历到第二层结点，到源点的距离为 2…… 可以看到，用 BFS 的话，距离源点更近的点会先被遍历到，这样就能找到到某个点的最短路径了。 LeetCode 1162 离开陆地的最远距离 你现在手里有一份大小为 N x N 的 网格 grid，上面的每个 单元格 都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的。 我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个单元格之间的距离是 |x0 - x1| + |y0 - y1| 。 如果网格上只有陆地或者海洋，请返回 -1。 示例 1： 输入：[[1,0,1],[0,0,0],[1,0,1]]输出：2解释：海洋单元格 (1, 1) 和所有陆地单元格之间的距离都达到最大，最大距离为 2。示例 2： 输入：[[1,0,0],[0,0,0],[0,0,0]]输出：4解释：海洋单元格 (2, 2) 和所有陆地单元格之间的距离都达到最大，最大距离为 4。 提示： 1 &lt;= grid.length == grid[0].length &lt;= 100grid[i][j] 不是 0 就是 1 参考作者：nettee链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/as-far-from-land-as-possible著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","link":"/2020/11/01/DFS-%E4%B8%8E-BFS-%E7%9A%84%E7%89%B9%E7%82%B9%E6%AF%94%E8%BE%83/"},{"title":"Kotlin Coroutines（协程）","text":"阅读《深入理解Kotlin协程》—— 霍丙乾 的读书笔记，博客内容多数为摘抄和总结，侵删。 注意：大家过年回家的抢票软件是携程，而我们 Kotlin 的 coroutines 翻译过来是协程。从名字看大概能猜到是异步的代码相互协作的程序。 What is Kotlin Corutines协程: 就是函数或者一段程序能够被 挂起 ，稍后再挂起的位置 恢复 。而线程是一旦开始就不会暂停，直到任务结束。线程之间是抢占式的调度，因此不存在协作问题。 挂起 和 恢复 是协程主动让出运行权来实现协作的，协程和核心也是程序自己处理挂起和恢复。 线程的调度一般是由操作系统实现控制的，而大多数协程是由于语言层面自己实现。 协程需要支持挂起和恢复，因此需要对挂起点的状态进行保存，他们是否开辟相应的调用栈有两种实现方式。 有栈协程（Stackful Coroutine）:协程有自己的调用栈，类似线程的，实现方式就类似线程的调度，不同点体现在调度上。 无栈协程（Stackless Coroutine）：协程没有自己的调用栈，挂起点的状态通过 状态机 或者 闭包 等语法实现。有栈协程总是会给协程开辟一块内存，因此内存消耗大大增加，而无栈协程就在内存方面比较有优势。（今年面试第一次被问到闭包，原来是因为这个。） Kotlin 的协程是一种无栈协程，他的控制流转依靠对协程体本身编译生成的装填机的状态流转实现。变量保存也是通过闭包语法来实现的。 调度过程中，根据协程调度权的转移目标不同又可以将协程分为 对协协程 和 非对协协程。 对协协程（Symmetric Coroutine） ：任何一个协程都是相互独立且平等的，调度前可以再任意协程之间转移。 非对协协程（Asymmetric Coroutine）：协程让出到底全的目标只能是他的调度者，即协程之间存在调用和被调用的关系。 How is that work ?Why use it ?","link":"/2020/10/18/Kotlin-Coroutines%EF%BC%88%E5%8D%8F%E7%A8%8B%EF%BC%89/"},{"title":"DFS 与 BFS 的特点比较","text":"树是非线性结构，对于存储一棵树不需要大块的连续内存，有利于提高计算机资源利用率。在实际生活场景中，深度优先搜索（DFS）和广度优先搜（BFS）索分别有哪些使用场景呢？ BFS 实际场景：BFS 求解 最短路径 或者 二分图判断 、最小生成树 ； 使用 队列 实现，一般会借助 哈希表 来优化时间复杂度； DFS 实际场景：文件目录的遍历，查找符合要求的文件。 一般使用 栈 实现，递归解法较容易实现； 空间复杂度高，和树的深度成正比，如果树比较深的话建议用 BFS； 解决深度 使用 DFS 深度优先遍历 给定一个二叉树，请寻找它的最大深度。 判断二叉树是否对称 递归解法： 双指针判断 迭代解法：层序遍历，根节点入队列两次，然后每次拉出来两个节点对比是否相等 前序遍历（自顶向下）根节点的深度是1。depth = 1, answer = 0; 1234567891011private int answer;private void maximum_depth(TreeNode root, int depth) { if (root == null) { return; } if (root.left == null &amp;&amp; root.right == null) { answer = Math.max(answer, depth); } maximum_depth(root.left, depth + 1); maximum_depth(root.right, depth + 1);} 后序遍历（自底向上）12345678public int maximum_depth(TreeNode root) { if (root == null) { return 0; // return 0 for null node } int left_depth = maximum_depth(root.left); int right_depth = maximum_depth(root.right); return Math.max(left_depth, right_depth) + 1; // return depth of the subtree rooted at root} 使用 BFS 进行层序遍历「BFS 遍历」、「层序遍历」、「最短路径」实际上是递进的关系。在 BFS 遍历的基础上区分遍历的每一层，就得到了层序遍历。在层序遍历的基础上记录层数，就得到了最短路径。 BFS 遍历是一类很值得反复体会和练习的题目。一方面，BFS 遍历是一个经典的基础算法，需要重点掌握。另一方面，我们需要能根据题意分析出题目是要求最短路径，知道是要做 BFS 遍历。 LeetCode 102 二叉树的层序遍历 123456789101112131415161718192021222324252627public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); if (root != null) { queue.add(root); } while (!queue.isEmpty()) { int n = queue.size(); List&lt;Integer&gt; level = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } res.add(level); } return res;} 使用 BFS 求解最短路径问题在一棵树中，一个结点到另一个结点的路径是唯一的，但在图中，结点之间可能有多条路径，其中哪条路最近呢？这一类问题称为最短路径问题。最短路径问题也是 BFS 的典型应用，而且其方法与层序遍历关系密切。 在二叉树中，BFS 可以实现一层一层的遍历。在图中同样如此。从源点出发，BFS 首先遍历到第一层结点，到源点的距离为 1，然后遍历到第二层结点，到源点的距离为 2…… 可以看到，用 BFS 的话，距离源点更近的点会先被遍历到，这样就能找到到某个点的最短路径了。 LeetCode 1162 离开陆地的最远距离 你现在手里有一份大小为 N x N 的 网格 grid，上面的每个 单元格 都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的。 我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个单元格之间的距离是 |x0 - x1| + |y0 - y1| 。 如果网格上只有陆地或者海洋，请返回 -1。 示例 1： 输入：[[1,0,1],[0,0,0],[1,0,1]]输出：2解释：海洋单元格 (1, 1) 和所有陆地单元格之间的距离都达到最大，最大距离为 2。示例 2： 输入：[[1,0,0],[0,0,0],[0,0,0]]输出：4解释：海洋单元格 (2, 2) 和所有陆地单元格之间的距离都达到最大，最大距离为 4。 提示： 1 &lt;= grid.length == grid[0].length &lt;= 100grid[i][j] 不是 0 就是 1 参考作者：nettee链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/as-far-from-land-as-possible著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","link":"/2020/11/01/DFS-%E4%B8%8E-BFS-%E7%9A%84%E7%89%B9%E7%82%B9%E6%AF%94%E8%BE%83/"}],"tags":[{"name":"binary tree","slug":"binary-tree","link":"/tags/binary-tree/"},{"name":"kotlin","slug":"kotlin","link":"/tags/kotlin/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Kotlin","slug":"Kotlin","link":"/categories/Kotlin/"}]}