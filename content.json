{"meta":{"title":"Life is a party","subtitle":"Let's get this party started!","description":"lizwangying blog","author":"Liz","url":"http://lizwangying.github.io/# Header"},"pages":[],"posts":[{"title":"Activity的正确打开方式","slug":"Activity的正确打开方式","date":"2016-08-21T14:31:32.000Z","updated":"2016-08-21T14:38:17.827Z","comments":true,"path":"2016/08/21/Activity的正确打开方式/","link":"","permalink":"http://lizwangying.github.io/# Header/2016/08/21/Activity的正确打开方式/","excerpt":"","text":"原文地址：Explain Activity Launch Mode With Examples 原文作者：songzhw 译文出自：掘金翻译计划 译者： Liz 校对者： mypchas6fans,hackerkevin adb shell dumpsys activity 输入这个命令可以得到一个清晰的 Task 视图，比如你有多少个 Task ，哪些 activity 在其对应的 Task 等相关信息。 下图是一张运行这个命令的输出截图。 从图中可以看出，有两个 Task (#103, #102) 。 Task #103 : affinity = “cn.six.task2”, size = 3 (它里面有三个activity) — Activity One — Activity Three — ActivityTwo Task #102 : affinity = “cn.six.adv”, size = 1 — Activity One 拥有了这个神奇的命令—— “adb shell dumpsys activity” ，我们就可以更好地探索 Activity 的启动模式啦… Default 到达此 activity 的 Intent ，系统会默认地在目标 Task 中创建一个新的实例并将默认的启动模式属性设置为 &quot;default&quot; 。 “Default” 是 activity 的默认启动模式，也就是说当你未给 activity 指定启动模式的时候，系统默认会给一个 “Default” 作为它的启动模式。 SingleTop 如果一个启动模式为 SingleTop 的 activity 实例在目标栈顶，intent 启动该 activity 时系统将通过 onNewIntent 的方法将 intent 传递给已有的那个实例而不会新创建一个的实例。 注意：并不是清除栈顶的 activity ！！！（也就是说只要栈顶不是本 activity ，都会创建新的实例，是本 activity 则重用不新建）。 SingleTask 这个是最难理解的，下文中我会搭配几个例子来细细讲解这个复杂的启动模式。 1. A(Default) -&gt; B(singleTask) 我们有两个 Activity ，A 和 B ，其中 B 是 SingleTask 模式，现在从 A 跳转到 B 。 首先在 Manifest 中写入启动模式，如下： 12345&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"cn.six.adv\"&gt; &lt;Activity android:name=\".A\"/&gt; &lt;Activity android:name=\".B\" android:launchMode=\"singleTask\"/&gt;&lt;/manifest&gt; Android 官方文档中提到 “ intent 启动一个（SingleTask） 的 Activity ，系统会将这个 Activity 创建在一个新的 Task 根部”。 SO ,听起来会是这个样子？ Task 1 Task 2 A B 但实际上，当我们运行命令 “adb shell dumpsys activity” 时，发现 B 这货诡异地和 A 出现在一个 Task 中。 Task 1 Task 2 B A (null) 这个问题有一点小难表达，因为这里面 B 使用了 android:taskAffinity 属性。 后文中会有详解。 2. A(Default) -&gt; B(singleTask) : B has a taskAffinity attribute 在 manifest 中这样写: 12345&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"cn.six.adv\"&gt; &lt;activity android:name=\".A\"/&gt; &lt;activity android:name=\".B\" android:launchMode=\"singleTask\" android:taskAffinity=\"task2\"/&gt;&lt;/manifest&gt; 在这里, A 启动 B 的效果就不一样啦。如下: Task 1 Task 2 A B 这个和上一个例子的唯一不同就是属性 “android:taskAffinity” 。 当你不声明 affinity 属性, 那么 activity 就会以包名作为其默认值。在这个例子中, 默认的 affinity 值就是 “cn.six.adv” 。 当 A 启动 B ，即使 B 的启动模式是 singleTask ，但也只有当 android:taskAffinity 属性和 A 不同时才会创建新的 task 。 看到这里，第一个例子是不是就顿时豁然开朗？ 为什么 A 和 B 在同一个 Task 中呢？因为它们的 taskAffinity 属性值是一样滴。 用逻辑来表达，就像是这样: 123456789A --&gt; B if( taskAffinity 属性相同) &#123; A 和 B 在同一个 Task 中 &#125; else &#123; B 在新的 Task 中，并且此 Task 的 affinity 属性值就是 B 的 &#125; 那么这个例子中, A 跳转 B, B 的启动模式是 “singleTask” , 并且 B 的 taskAffinity 不是 “cn.six.adv” 。 所以 B 会在一个新建的 Task 中。 Task 1 (affinity=”cn.six.adv”) Task 2 (affinity=”task2″) A B 3. A(default) -&gt; B(singleTask) -&gt; C(singleTask) -&gt; B(singleTask) manifest 如下: 123456&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"cn.six.adv\"&gt; &lt;activity android:name=\".A\"/&gt; &lt;activity android:name=\".B\" android:launchMode=\"singleTask\" android:taskAffinity=\"task2\"/&gt; &lt;activity android:name=\".C\" android:launchMode=\"singleTask\" android:taskAffinity=\"task2\"/&gt;&lt;/manifest&gt; (1). A -&gt; B Task 1 (affinity=”cn.six.adv”) Task 2 (affinity=”task2″) A B (2) A -&gt; B -&gt; C 因为 C 的 affinity 是 “task2” ，而 Task 中已经有一个和它一样属性值的 B ，所以 C 会被放在 Task 2 中。 Task 1 (affinity=”cn.six.adv”) Task 2 (affinity=”task2″) A C B (3) A -&gt; B -&gt; C -&gt; B 首先看一下实际结果 Task 1 (affinity=”cn.six.adv”) Task 2 (affinity=”task2″) A B 好奇怪啊！ C 去哪里啦？ 事情呢，是这个样子滴。 C-&gt;B ， B 的启动模式是 singleTask 而且它的 affinity 属性值是 “task2”, 当系统发现有一个 affinity 属性值为 task2 的 Task 2 所以就把 B 放进去了。但是, 其中已经有一个 B 的实例在 Task 2 之中。 所以系统会将已有的 B 的实例赋予一个 CLEAR_TOP （清除顶部）标志。所以 C 是这么没的。 4. SingleTask 小结 1234567891011if( 发现一个 Task 的 affinity == Activity 的 affinity )&#123; if(此 Activity 的实例已经在这个 Task 中)&#123; 这个 Activity 启动并且清除顶部的 Acitivity ，通过标识 CLEAR_TOP &#125; else &#123; 在这个 Task 中新建这个 Activity 实例 &#125;&#125; else &#123; // Task 的 affinity 属性值与 Activity 不一样 新建一个 affinity 属性值与之相等的 Task 新建一个 Activity 的实例并且将其放入这个 Task 之中&#125; SingleInstance SingleInstance 要比 SingleTask 好理解很多。 如果一个 Activity 的启动模式为 SingleInstance, 那么这个 Activity 必定会在一个新的 Task 之中, 并且这个 Task 之中有且只能有一个 Activity 。 再来一波栗子。 1. A(default) –&gt; B(singleInstance) –&gt; C(default) (1). A -&gt; B Task 1 Task 2 A B (2). A -&gt; B -&gt; C 拥有 “singleInstance” 启动模式的 activity 不予许其他任何 Activity 在它的 Task 之中。所以它是这个 Task 之中的独苗啊。当它跳转另外一个 activity 时, 那个 Activity 将会被分配到另外一个 Task 之中——就像是 intent 被赋予了 FLAG_ACTIVITY_NEW_TASK 标志一样。 由于 B 需要一个只能容纳它的 Task , 所以 C 会被加上一个 FLAG_ACTIVITY_NEW_TASK 标识。所以 C(default) 变成了 C(singleTask) 。 然后结果变成了这样: Task 1 Task 2 c A B 注：如果跳转的流程是 “A(default) –&gt; B(singleTask) –&gt; C(default)”, 那么结果会是这样： Task 1 Task 2 A C B 如何去运用启动模式呢？ 假如, 你需要在 service 在后台中做一些耗时操作，当它完成时, 你需要从此 service 中跳转进入一个 Activity 中，你会怎样做？ Service 是 Context 一种扩展, 它含有 startActivity(intent) 方法。但是当你调用 service.startActivity(intent)时，你的程序必然会崩。报错如下： 12345AndroidRuntimeException : \"Calling startActivity() from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?\" 这就是上文中提到的。当一个 Activity A 跳转进入另一个 Activity B (它们的启动模式都为默认的 default ), 所以这个 B 会和 A 在一个 Task 之中。但是当你想让 service 跳转到 Activity B, 由于 service 并不是一个 Activity , 所以它没有相关的 task 信息。所以 Service 不会出现在 Activity 的任务栈之中。这种情况下，Activity B 就不知道自己的 Task 在哪里了。 为了解决上述问题，我们可以告诉 Activity B 它应该在一个新的 Task 之中: 12345// \"this\" is a serviceIntent it = new Intent(this, ActivityB.class); it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);this.startActivity(it); 瞅见没？这才是 Activity 的启动模式的正确打开方式。","categories":[{"name":"Android","slug":"Android","permalink":"http://lizwangying.github.io/# Header/categories/Android/"},{"name":"翻译","slug":"Android/翻译","permalink":"http://lizwangying.github.io/# Header/categories/Android/翻译/"}],"tags":[{"name":"translation","slug":"translation","permalink":"http://lizwangying.github.io/# Header/tags/translation/"}]},{"title":"产品设计怎样做才最优雅","slug":"产品设计怎样做才最优雅","date":"2016-08-12T13:07:21.000Z","updated":"2016-08-21T14:40:18.262Z","comments":true,"path":"2016/08/12/产品设计怎样做才最优雅/","link":"","permalink":"http://lizwangying.github.io/# Header/2016/08/12/产品设计怎样做才最优雅/","excerpt":"","text":"原文链接 : How To Make Your Not-So-Great Visual Design Better 原文作者 : Jasmine Friedl 译文出自 : 掘金翻译计划 译者 : Liz 校对者: Gran，Jiegao Zhu Photo by William Iven 图片来自 William Iven 如何才能改进你的产品视觉设计呢？ 这个问题困扰了很多人。我在产品设计方向辅导、指导了很多学生，比如在圣弗朗西斯科艺术学院担任导师，在 AIGA Portfolio Day 作为产品复审，在 Facebook 辅导实习生等。 学生的观念与专业产品设计师之间有这样一座桥梁，它由敬畏、激情、好奇心和满腹的疑问组成。 “我毕业后会何去何从？” “设计相关的工作都有什么？” “我适合做什么样的工作？” “如果我找不到工作怎么办？” “如果根本没有职位招聘怎么办？” “我能为找工作准备些什么？” 最近，我们在 Facebook 举办了一场自我评论，其中有一位来自康奈尔大学的学生 Jon Lee。在我们为数不多的互动中，他身上有一些东西我很欣赏。那就是他的自我认知。他了解自己在视觉设计上有哪些地方需要提高。他有如此清晰地自我认知，归功于他从潜在的雇主身上得到的反馈，就像很多即将步入职场的同学一样，好奇作为一个设计师需要什么样的技能。他想知道怎样才能做得更好一点。 成为一个产品设计老司机需要广泛的技能，具备 visual chops 是很重要的，尤其是在 Facebook。令我兴奋的是，Jon 在这方面很好奇，如果他现在在我身边，我会问 Jon 一个曾问过很多同学的问题，并给他提供一个方案，希望能够在 这个项目之外对他有所帮助。 这里有一个 Jon 分享的设计作品概览。从这里开始他才真正地在视觉设计的道路上踏上正轨。 Jon Lee 为应用 Nearspace 设计的概念图。 在 Facebook，我们经常将视觉设计的评判标准分为工艺和执行力。为了能够评估 Jon 这个作品的水平，并且激励他设计出更好的作品，我需要在评价他的作品之前向他提问和调查，因为这样更好地了解了别人的设计意图。 你的层次结构是什么? 你修改过你的设计风格么？我看到了两个风格（标题的大小写问题），至少三种大小类型、两种颜色、还有居中和左对齐两种类型。 header（头部）风格是哪一种？按钮的风格是什么？ body copy（广告正文）的风格呢？ metadata（元数据）呢？ 你使用的是什么样式？ 按钮的字体有两种大小，两种按钮高度，两个外壳，三种颜色，我还看到了带有 icon（图标）的按钮。 有两个不同的列表样式。一个显然是关于实时的发现模式（照片和业务名称、类别和星级），另一个看起来像一个线框（最近的发布的）。 列表和按钮的设计风格有什么区别？在概要文件页面，卡片、按钮和列表是使用相同的白色背景，灰色轮廓样式。他们应该设计成不同的风格么？ 这种设计样式和现有的或已经发布的样式哪家强？ 如果选项能够切换，那么他们会自动切换么？取消和应用有必要么？ 点击返回和点击取消是一样的么？把右上角换成X可以么？ 我看到有一个重置按钮但是它没有起到任何过滤的作用。有必要在这种情况下添加这个按钮么？应用按钮能够取代重置按钮么？ 从用户体验角度，需要这个底部的导航条么？ 在同一垂直方向上的这些控件是否平行？他们都是必要的么？ 你的 margin（外边距）和 padding（内边距）的规范是什么？ 我从附近页面和资料页面看到很多细微的外边距；过滤页面更具有明显的外边距。 在附近页面的竖直方向的地步导航几乎贴近了屏幕的边缘。 为什么不用网格布局？ 你的 icon（图标）表达出想要呈现的意思么？ 我看到一个表示“座位”的图标有单个座位、三个座位和六个座位的图片聚集在一起。这是一个座位的计数还是一些座位数的大约值？又或者是一系列的座位么？有没有一个更好的方式来设计表达这个含义？这是“团购”有优惠的意思么？有没有另一种方式设计它？ 为什么没有明显的标志表示两个相反的意思？如果不是重要的元素，为什么你要显示出来这种无足轻重的元素？初步结果难道不应该包含所有可用的选项么？ Pie (派，一种食物)在这里是想表达 pie (派)？还是指代甜点？又或是代指所有食物？杯饮料意味着什么？你是假定认为每个餐厅都能够提供饮料吗?有更好的分组吗? 你的选择设计风格的一致么？ 我看到在使用下拉过滤功能时，有一些过滤按钮选项的样式略有不同。 一些只有 icon (图标) 的按钮，而某些按钮只有文字。 一个按钮有角度，然而其他没有。 wifi 图标的线很粗；但是插座的线很细。有些像素化，有的则不是。一些是黑色的，又有一些是灰色的。 大多数的卡片和按钮拥有同样的样式：角弧度半径，轮廓，填充颜色等风格。他们是不是过于一致？ 屏幕上所有的元素都是必要的么？ 在搜索区域上方有一个分割线，还有每一个可选选项下方也有一个分割线。 有一处使用了绿色 导航使用了 icon (图标) 和文字，它们有同时存在的必要吗？ 你怎样选择你的配色方案的？ 你的配色方案是比较简约的暖色调，除了一个亮绿色的按钮。你有怎样的设计原则，在哪些地方应用了？ 你的拼写、语法和标点符号正确吗?你的内容有逻辑吗? “Nearby（附近）” 页面和 “Profile（概况）” 页面底部的导航条经常出现，但是这个 “add（添加）”是什么鬼?添加什么? “Availability” 这个单词拼错了。 这个 “Availability（可用）” 有存在的必要么？ 页面的“阅读量”是怎样计算的？（是读完所有文字还是只是匆匆一瞥算是一次阅读量的累积）你的页面标题是“过滤器”，但是你的头部显示为“距离”，另外这个页面可以过滤剩余可得座位，有无 Wifi ,插座和食物/饮料。但是你能向你的朋友解释清楚这个页面能做什么？这些页面结构合理么？它们的命名正确么？ 这个设计可移植性高么？ 如果你是为安卓平台设计的这款桌面，在其他平台你也会做出同样的设计决策么？在不同平台下，你的设计决策会不同么？ 如何改进你的产品视觉设计？ 解答以上这些问题只是一个设计作品成功的开始。成为一枚优秀的设计师——成为一枚牛掰的“视觉”设计师——需独具匠心。这意味着你在以一个设计师的角度来考虑和解答每一个问题，而不是别人发现这些问题时木已成舟，那就为时已晚了。 接下来的工作就是“针对性”的回答这些问题，确保你的设计意图是基于坚实的设计原则、研究和对细节的关注，当然啦，比如类似于风格和偏好这种问题，就会非常棘手。因为不是每个设计师的都有这些意识或者是理由充足的主意。这很正常，因为在提高你的设计的道路上，你首要做到的就是接受你的作品现在还并不完美。 Ira Glass 对此有很棒的观点: 没人会向别人吐槽菜鸟——就算有人看出我菜，我也希望他不要嘲讽我——因为我们都是搞创作的...我们从事这行是因为我们有品位。这就像是一个瓶颈期，最初的几年你创作的东西，现在看来你是不是认为他们很一般？对吧？它们并不咋地。它们真的就是一般。但是你在努力地做到好，你有信心自己能够做好，但虽然你的作品真的没那么优秀。但是你的品位——用来搞创作的装备——还是你作品的修正符，它就是当你在看到你所创作的成果时心中略过的那丝丝缕缕的失望，你懂伐？ 如果你有品位，它就能自己告诉你还有多少需要提高的地方，和应该怎样提高你的视觉设计。 多观察世界上设计作品然后形成自己的见解什么是好的,什么是不好的。在你的见解中加强基础的设计原则。 多浏览设计系统的搭建比如材料设计（material design）和人机界面指南（Human Interface Guidelines）。 多练手 多浏览网站、多下载 app ，在 Dribbble （一个有名的设计网站）上浏览优秀的设计作品，切记不能复制别人的作品，而是问为什么这样设计就好呢？然后去揣摩答案。 依然是勤动手练习 向那些有设计见解的人展示你的作品——就是那些技术不错的老司机设计师们，听取他们对于你的作品的意见，然后思考他们对于你的作品背后的设计意向。然后去找答案。 不断地自我反思比如我们刚刚提到的。 现在我可以给 Jon 一些反馈，比如你的“设计风格种类遍地都是”、“你的绿色按钮格外突兀”。我还给他指明了一些解决办法比如“左对齐所有过滤器的类别中的按钮”、“缩小按钮的圆角半径”、“为你的品牌颜色选择一个亮色调”，如果“你”想使你的作品更好，就要不断打磨，细细雕琢。 别人对你作品反馈和指导能够起到同样的作用;进步最快的方法通常是实践出真知，而不是只懂得规范 。 练习才能进步。一次又一次的努力尝试这种执行能力是初学者们第一次进入设计师这个角色,一旦设计师这个角色在你心中落定，它会一步一步引导你进步。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://lizwangying.github.io/# Header/categories/翻译/"}],"tags":[{"name":"translation","slug":"translation","permalink":"http://lizwangying.github.io/# Header/tags/translation/"}]},{"title":"Google官方MVP Demo学习搭建Android 项目架构","slug":"Google官方MVP-Demo学习搭建Android-项目架构","date":"2016-08-01T15:43:18.000Z","updated":"2016-08-01T16:12:25.681Z","comments":true,"path":"2016/08/01/Google官方MVP-Demo学习搭建Android-项目架构/","link":"","permalink":"http://lizwangying.github.io/# Header/2016/08/01/Google官方MVP-Demo学习搭建Android-项目架构/","excerpt":"","text":"作者：王颖，转载请注明出处 lizwangying - lizwangying.github.io 首先，奉上**Google官方github**。 大概翻译一下ReadMe，服务一下英语不好的小伙伴。有不正之处，请大家一定要纠正我哦，谢谢。 Android 架构蓝图[测试] 组织和架构一个Android应用程序框架的时候可以具有很强的灵活性。当然，这种自由，虽然很赞但同时给用用程序带来了庞大的类库，不统一的命名方式和架构（或者缺乏），这使得测试，维护还有扩展都很困难。 安卓系统架构蓝图就是为了展示尽可能解决这些问题的方法给大家。在这个项目中，我们提供了相同的应用程序使用了不同的架构概念和工具。 您可以使用这些样本作为参考或者作为您自己的应用程序的起点。我们这里着重展示代码架构、体系结构、测试和可维护性。注意，有很多方法可以使用这些体系结构和工具构建应用程序，根据您的优先级选择。这些例子不是唯一不可的例子，请以保持UI为最简单原则来构建您的App架构。 哦，基本大家都能看懂，我就不翻译了。下面记录一下学习心得。挨个来...","categories":[{"name":"Github源码学习","slug":"Github源码学习","permalink":"http://lizwangying.github.io/# Header/categories/Github源码学习/"}],"tags":[{"name":"Android Architecture","slug":"Android-Architecture","permalink":"http://lizwangying.github.io/# Header/tags/Android-Architecture/"},{"name":"MVP","slug":"MVP","permalink":"http://lizwangying.github.io/# Header/tags/MVP/"},{"name":"translation","slug":"translation","permalink":"http://lizwangying.github.io/# Header/tags/translation/"}]},{"title":"JavaScript老司机快速入门，知识点总结","slug":"javaScript入门","date":"2016-07-25T13:11:52.000Z","updated":"2016-08-07T05:16:37.757Z","comments":true,"path":"2016/07/25/javaScript入门/","link":"","permalink":"http://lizwangying.github.io/# Header/2016/07/25/javaScript入门/","excerpt":"","text":"作者：王颖，转载请注明出处 lizwangying - lizwangying.github.io 哈哈，这里的老司机指的是：有（任何）语言的编程基础（除了JS）的老司机们 因为Hexo非常酷，so打算自己写一套模板，学一学JavaScript这么酷的东西 概要 Step one-&gt;如何插入JS？ 非小白，一眼就懂的基础知识点点点 常用的酷酷滴方法 DOM操作 Step one-&gt;如何插入JS？ JavaScript这个东西酷在什么地方？他就是很神奇！她长在哪里都行，就是这么任性爱自由！！！Seriously！！！ 第一个位置，在&lt;head&gt;&lt;/head&gt;标签里面，例如在index.html中 [index.html]123456789101112131415&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;JS代码爱自由，放在Head里&lt;/title&gt;&lt;script type=\"text/javascript\"&gt; document.write(\"I love\");&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt; document.write(\"JS代码爱自由，放在Head里\");&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 外部引用JS HTML文件可以和JS代码分开,单独创建一个JavaScript文件,文件后缀名为.js，然后将JS代码直接写在JS文件中,此处注意文件路径。 这里的路径就为index.html同级目录下名字为script.js文件。那么这个文件里面可以直接写js代码，不需要添加根标签&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 。 &lt;!--more--&gt; [index.html]1234567891011&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;外部引用JS文件&lt;/title&gt;&lt;script src=\"script.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; document.write(\"外部引用JS文件\");&lt;/body&gt;&lt;/html&gt; 神奇的JavaScript哪里都能放，我说的就是&lt;body&gt;&lt;/body&gt;里面。大家都知道，一个html文件，body里面的标签多了去了，script就像是一个癌细胞，哪里都能长。任何标签，任何元素。 非小白，一眼就懂的基础知识点点点 本人有Java基础， 编程语言有很多共通点，所以总结的东西就是和java不同需要注意的地方。所以如果您是纯小白，我建议您移步慕课网-JavaScript入门篇，酷酷的学习网站，网页编辑器，立马就能预览你的代码，本篇文章就是我耐心学完之后总结的学习笔记。 代码结尾加分号； 注释： //单行注释、 /* 多行注释 */ 变量声明：JavaScript是弱类型语言，所以再也不用定义类型，一切变量都是对象，所以没有Java那样的基本类型，更没有强制转换之类的，所有的变量都用var声明。如果你不写var声明变量也可以，它自动会认为你写了。这是我最喜欢JavaScript的地方，比Java可爱！ 方法都叫function，定义格式： [index.html]1234function 函数名()&#123; 函数代码;&#125; 常用的酷酷滴方法 输出内容：document.write(&quot;I love JavaScript！&quot;);---&gt;相当于Java中的system.out.ln(&quot;I love JavaScript！&quot;); 弹框：alert(字符串或变量); 消息对话框： confirm(str)当用户点击&quot;确定&quot;按钮时，返回true 当用户点击&quot;取消&quot;按钮时，返回false,通过返回值可以判断用户点击了什么按钮。忍不住举个栗子，因为想表达一下var它能够什么都声明，不管是对象，还是基本变量类型，真的是啥都能！！！ [index.html]1234567&lt;script type=\"text/javascript\"&gt; var mymessage=confirm(\"你喜欢JavaScript吗?\"); if(mymessage==true) &#123; document.write(\"很好,加油!\"); &#125; else &#123; document.write(\"JS功能强大，要学习噢!\"); &#125;&lt;/script&gt; 这里var用来声明的是个咱们java中所说的boolean，帅吧！ 消息对话框： prompt(str1, str2); ， 参数str1: 要显示在消息对话框中的文本。 str2：文本框中的内容，可以修改，其实就是默认输入的内容。这个就是一个弹框加一个文本框，用来接收用户输入信息。 打开新窗口window.open([URL], [窗口名称], [参数字符串]) 参数说明 [index.html]123456789101112/* @params URL：可选参数，在窗口中要显示网页的网址或路径。*如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。*@params 窗口名称：可选参数，被打开窗口的名称。* 1.该名称由字母、数字和下划线字符组成。* 2.\"_top\"、\"_blank\"、\"_selft\"具有特殊意义的名称。 _blank：在新窗口显示目标网页 _self：在当前窗口显示目标网页 _top：框架网页中在上部窗口中显示目标网页* 3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。* 4.name 不能包含有空格。@params 参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。*/","categories":[{"name":"前端","slug":"前端","permalink":"http://lizwangying.github.io/# Header/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lizwangying.github.io/# Header/tags/JavaScript/"},{"name":"html+CSS","slug":"html-CSS","permalink":"http://lizwangying.github.io/# Header/tags/html-CSS/"}]},{"title":"博客第一篇","slug":"博客第一篇","date":"2015-12-16T08:16:11.000Z","updated":"2015-12-16T08:18:44.257Z","comments":true,"path":"2015/12/16/博客第一篇/","link":"","permalink":"http://lizwangying.github.io/# Header/2015/12/16/博客第一篇/","excerpt":"","text":"First blog 支持markdown? 开始写博客啦","categories":[],"tags":[]}]}